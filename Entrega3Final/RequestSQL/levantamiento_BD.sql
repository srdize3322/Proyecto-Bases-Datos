-- Este levantamiento es el mismo orden que probé en mi laptop localmente en postgres server
-- los comentarios documentan las decisiones para replicar el proceso
\set ON_ERROR_STOP on

BEGIN;

-- Define el esquema lógico y carga los CSV depurados
-- incluyendo el nuevo maestro de planes Depurado/MaestroPlanes_OK.csv

DROP SCHEMA IF EXISTS dccolita CASCADE;
CREATE SCHEMA dccolita;
SET search_path TO dccolita;
-- arranco con schema limpio para evitar residuos de pruebas

-- Catálogo de instituciones previsionales 
CREATE TABLE institucion_previsional (
    codigo INTEGER PRIMARY KEY,
    nombre VARCHAR(150) NOT NULL UNIQUE,
    tipo VARCHAR(10) NOT NULL,
    rut VARCHAR(12) NOT NULL,
    enlace VARCHAR(200),
    CONSTRAINT institucion_tipo_ck CHECK (tipo IN ('abierta', 'cerrada')),
    CONSTRAINT institucion_rut_ck CHECK (rut ~ '^[0-9]{1,8}-[0-9Kk]$'),
    CONSTRAINT institucion_enlace_ck CHECK (enlace IS NULL OR enlace ~ '^[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
);

-- Firmas electrónicas asociadas a profesionales.
CREATE TABLE firma (
    firma_id INTEGER PRIMARY KEY,
    ruta TEXT NOT NULL UNIQUE
);

-- Planes de salud 
CREATE TABLE plan_salud (
    institucion_nombre VARCHAR(150) NOT NULL,
    grupo VARCHAR(150) NOT NULL,
    bonificacion SMALLINT NOT NULL,
    CONSTRAINT plan_salud_pk PRIMARY KEY (institucion_nombre, grupo),
    CONSTRAINT plan_bonificacion_ck CHECK (bonificacion BETWEEN 0 AND 100),
    CONSTRAINT plan_institucion_fk FOREIGN KEY (institucion_nombre)
        REFERENCES institucion_previsional (nombre) ON UPDATE CASCADE
);
CREATE INDEX plan_salud_institucion_idx ON plan_salud (institucion_nombre);

-- Personas (pacientes, profesionales, administrativos, titulares y cargas).
CREATE TABLE persona (
    persona_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    run VARCHAR(10) NOT NULL UNIQUE,
    nombre VARCHAR(50) NOT NULL,
    apellidos VARCHAR(100) NOT NULL,
    direccion VARCHAR(200),
    correo VARCHAR(254),
    telefono VARCHAR(20),
    tipo_persona VARCHAR(12),
    titular_run VARCHAR(10),
    rol VARCHAR(30),
    profesion VARCHAR(30),
    especialidad VARCHAR(100),
    firma_id INTEGER,
    institucion_nombre VARCHAR(150),
    CONSTRAINT persona_run_format_ck CHECK (run ~ '^[0-9]{1,8}-[0-9Kk]$'),
    CONSTRAINT persona_tipo_ck CHECK (tipo_persona IS NULL OR tipo_persona IN ('titular', 'beneficiario')),
    CONSTRAINT persona_correo_ck CHECK (correo IS NULL OR correo ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    CONSTRAINT persona_telefono_ck CHECK (telefono IS NULL OR telefono ~ '^[0-9]{9}$'),
    CONSTRAINT persona_titular_fk FOREIGN KEY (titular_run) REFERENCES persona (run) DEFERRABLE INITIALLY DEFERRED,
    CONSTRAINT persona_institucion_fk FOREIGN KEY (institucion_nombre) REFERENCES institucion_previsional (nombre) ON UPDATE CASCADE,
    CONSTRAINT persona_titular_distinto_ck CHECK (
        titular_run IS NULL
        OR tipo_persona = 'titular'
        OR titular_run <> run
    ),
    CONSTRAINT persona_titular_consistencia_ck CHECK (
        tipo_persona IS NULL
        OR (tipo_persona = 'titular' AND (titular_run IS NULL OR titular_run = run))
        OR (tipo_persona = 'beneficiario' AND titular_run IS NOT NULL)
    ),
    CONSTRAINT persona_firma_fk FOREIGN KEY (firma_id) REFERENCES firma (firma_id) ON UPDATE CASCADE
);
CREATE INDEX persona_institucion_idx ON persona (institucion_nombre);
CREATE INDEX persona_titular_idx ON persona (titular_run);

-- Relación many to many entre personas y planes.
CREATE TABLE persona_plan (
    persona_id INTEGER NOT NULL REFERENCES persona (persona_id) ON DELETE CASCADE,
    institucion_nombre VARCHAR(150) NOT NULL,
    grupo VARCHAR(150) NOT NULL,
    es_titular BOOLEAN NOT NULL DEFAULT FALSE,
    fecha_inicio DATE,
    fecha_fin DATE,
    CONSTRAINT persona_plan_pk PRIMARY KEY (persona_id, institucion_nombre, grupo),
    CONSTRAINT persona_plan_plan_fk FOREIGN KEY (institucion_nombre, grupo)
        REFERENCES plan_salud (institucion_nombre, grupo) ON DELETE CASCADE,
    CONSTRAINT persona_plan_fechas_ck CHECK (
        fecha_inicio IS NULL OR fecha_fin IS NULL OR fecha_fin >= fecha_inicio
    )
);
CREATE INDEX persona_plan_plan_idx ON persona_plan (institucion_nombre, grupo);

-- Catálogo de prestaciones FONASA
CREATE TABLE prestacion (
    prestacion_id SERIAL PRIMARY KEY,
    codigo_fonasa VARCHAR(15) NOT NULL,
    codigo_adicional VARCHAR(15),
    codigo_fonasa_full VARCHAR(30) NOT NULL,
    descripcion VARCHAR(150) NOT NULL,
    grupo VARCHAR(100) NOT NULL,
    tipo VARCHAR(100),
    valor_fonasa INTEGER NOT NULL,
    CONSTRAINT prestacion_codigo_full_uk UNIQUE (codigo_fonasa_full),
    CONSTRAINT prestacion_valor_ck CHECK (valor_fonasa >= 0)
);
CREATE INDEX prestacion_grupo_idx ON prestacion (grupo);

-- Valores propios del arancel dcc
CREATE TABLE arancel_dc (
    codigo_interno INTEGER PRIMARY KEY,
    codigo_fonasa VARCHAR(30),
    descripcion VARCHAR(150) NOT NULL,
    valor_dc INTEGER NOT NULL,
    CONSTRAINT arancel_dc_valor_ck CHECK (valor_dc >= 0),
    CONSTRAINT arancel_dc_prestacion_fk FOREIGN KEY (codigo_fonasa)
        REFERENCES prestacion (codigo_fonasa_full) ON UPDATE CASCADE
);
CREATE INDEX arancel_dc_fonasa_idx ON arancel_dc (codigo_fonasa);

-- Catálogo de productos farmacéuticos normalizados
CREATE TABLE farmaco (
    farmaco_codigo INTEGER PRIMARY KEY,
    nombre_generico VARCHAR(200) NOT NULL,
    descripcion TEXT NOT NULL,
    tipo VARCHAR(200) NOT NULL,
    codigo_onu INTEGER,
    clasificacion_onu VARCHAR(200),
    clasificacion_interna VARCHAR(150) NOT NULL,
    estado VARCHAR(10) NOT NULL,
    es_canasta_esencial BOOLEAN NOT NULL DEFAULT FALSE,
    precio INTEGER,
    CONSTRAINT farmaco_estado_ck CHECK (estado IN ('activo', 'inactivo')),
    CONSTRAINT farmaco_precio_ck CHECK (precio IS NULL OR precio >= 0)
);
CREATE INDEX farmaco_tipo_idx ON farmaco (tipo);

-- Registro de atenciones médicas
CREATE TABLE atencion (
    atencion_id INTEGER PRIMARY KEY,
    fecha DATE NOT NULL,
    paciente_run VARCHAR(10) NOT NULL REFERENCES persona (run) ON UPDATE CASCADE,
    profesional_run VARCHAR(10) NOT NULL REFERENCES persona (run) ON UPDATE CASCADE,
    diagnostico VARCHAR(100),
    efectuada BOOLEAN NOT NULL DEFAULT FALSE
);
CREATE INDEX atencion_paciente_idx ON atencion (paciente_run);
CREATE INDEX atencion_profesional_idx ON atencion (profesional_run);
CREATE INDEX atencion_fecha_idx ON atencion (fecha);

-- Órdenes de prestación emitidas en una atención.
CREATE TABLE orden (
    atencion_id INTEGER NOT NULL REFERENCES atencion (atencion_id) ON DELETE CASCADE,
    codigo_arancel INTEGER NOT NULL REFERENCES arancel_dc (codigo_interno),
    descripcion VARCHAR(150) NOT NULL,
    CONSTRAINT orden_pk PRIMARY KEY (atencion_id, codigo_arancel, descripcion)
);
CREATE INDEX orden_atencion_idx ON orden (atencion_id);
CREATE INDEX orden_arancel_idx ON orden (codigo_arancel);

-- Medicamentos prescritos durante una atención.
CREATE TABLE medicamento_prescrito (
    atencion_id INTEGER NOT NULL REFERENCES atencion (atencion_id) ON DELETE CASCADE,
    medicamento_nombre VARCHAR(200) NOT NULL,
    farmaco_codigo INTEGER REFERENCES farmaco (farmaco_codigo),
    posologia VARCHAR(200) NOT NULL,
    es_psicotropico BOOLEAN NOT NULL,
    CONSTRAINT medicamento_prescrito_pk PRIMARY KEY (atencion_id, medicamento_nombre),
    CONSTRAINT medicamento_prescrito_farmaco_unq UNIQUE (atencion_id, farmaco_codigo)
);
CREATE INDEX medicamento_prescrito_atencion_idx ON medicamento_prescrito (atencion_id);
CREATE INDEX medicamento_prescrito_farmaco_idx ON medicamento_prescrito (farmaco_codigo);

-- Carga de datos depurados (ordenada por dependencias)

CREATE TEMP TABLE carga_log (
    orden SERIAL,
    mensaje TEXT NOT NULL
);

INSERT INTO carga_log (mensaje)
VALUES ('[inicio] Levantamiento y carga de datos depurados');

-- Instituciones previsionales.
CREATE TEMP TABLE stg_institucion_previsional (
    codigo INTEGER,
    nombre TEXT,
    tipo TEXT,
    rut TEXT,
    enlace TEXT
) ON COMMIT DROP;

\copy stg_institucion_previsional FROM 'Depurado/Instituciones previsionales de salud_OK.csv' WITH (FORMAT csv, HEADER true, DELIMITER ';');

INSERT INTO institucion_previsional (codigo, nombre, tipo, rut, enlace)
SELECT
    codigo,
    upper(trim(nombre)),
    lower(trim(tipo)),
    upper(trim(rut)),
    NULLIF(lower(trim(enlace)), '')
FROM stg_institucion_previsional;

INSERT INTO carga_log (mensaje)
SELECT format('[institucion_previsional] staging=%s → insertadas=%s',
              (SELECT count(*) FROM stg_institucion_previsional),
              (SELECT count(*) FROM institucion_previsional));

-- Planes de salud (maestro unificado).
CREATE TEMP TABLE stg_plan_salud (
    institucion TEXT,
    grupo TEXT,
    bonificacion_text TEXT
) ON COMMIT DROP;
-- estos archivos los revisé en excel para confirmar que bonificacion y grupo venían en ese orden

\copy stg_plan_salud FROM 'Depurado/MaestroPlanes_OK.csv' WITH (FORMAT csv, HEADER true, DELIMITER ';');

WITH institucion_alias AS (
    SELECT
        nombre,
        regexp_replace(nombre, '[^A-Z0-9]', '', 'g') AS normalizado
    FROM institucion_previsional
),
planes_normalizados AS (
    SELECT
        regexp_replace(upper(trim(institucion)), '[^A-Z0-9]', '', 'g') AS normalizado,
        trim(grupo) AS grupo,
        COALESCE(NULLIF(trim(bonificacion_text), '')::SMALLINT, 0) AS bonificacion
    FROM stg_plan_salud
)
-- esta normalización alfanumérica la saqué de un ejemplo en stack overflow cuando buscaba limpiar nombres
INSERT INTO plan_salud (institucion_nombre, grupo, bonificacion)
SELECT DISTINCT ON (ia.nombre, pn.grupo)
    ia.nombre,
   pn.grupo,
    pn.bonificacion
FROM planes_normalizados pn
JOIN institucion_alias ia ON pn.normalizado = ia.normalizado
ORDER BY ia.nombre, pn.grupo, pn.bonificacion DESC;

INSERT INTO carga_log (mensaje)
SELECT format('[plan_salud] staging=%s → insertadas=%s',
              (SELECT count(*) FROM stg_plan_salud),
              (SELECT count(*) FROM plan_salud));

-- Personas + firmas (se utilizan staging para normalizar rutas e instituciones).
CREATE TEMP TABLE stg_persona (
    persona_id TEXT,
    run TEXT,
    nombre TEXT,
    apellidos TEXT,
    direccion TEXT,
    correo TEXT,
    telefono TEXT,
    tipo TEXT,
    titular TEXT,
    rol TEXT,
    profesion TEXT,
    especialidad TEXT,
    firma TEXT,
    institucion TEXT,
    reservado TEXT
) ON COMMIT DROP;

\copy stg_persona FROM 'Depurado/Persona_OK.csv' WITH (FORMAT csv, HEADER true, DELIMITER ';');

INSERT INTO firma (firma_id, ruta)
SELECT DISTINCT
    regexp_replace(firma, '[^0-9]', '', 'g')::INTEGER AS firma_id,
    firma
FROM stg_persona
WHERE firma IS NOT NULL
  AND firma <> ''
  AND regexp_replace(firma, '[^0-9]', '', 'g') <> ''
ON CONFLICT (firma_id) DO NOTHING;

INSERT INTO carga_log (mensaje)
SELECT format('[firma] rutas válidas=%s', count(*))
FROM firma;

INSERT INTO persona (
    run, nombre, apellidos, direccion, correo, telefono, tipo_persona,
    titular_run, rol, profesion, especialidad, firma_id, institucion_nombre
)
SELECT
    upper(trim(run)),
    trim(nombre),
    trim(apellidos),
    NULLIF(trim(direccion), ''),
    NULLIF(trim(correo), ''),
    CASE
        WHEN length(regexp_replace(coalesce(telefono, ''), '\\D', '', 'g')) = 9
            THEN regexp_replace(telefono, '\\D', '', 'g')
        ELSE NULL
    END,
    CASE WHEN trim(tipo) = '' THEN NULL ELSE lower(trim(tipo)) END,
    CASE WHEN trim(titular) = '' THEN NULL ELSE upper(trim(titular)) END,
    NULLIF(trim(rol), ''),
    NULLIF(trim(profesion), ''),
    NULLIF(trim(especialidad), ''),
    CASE
        WHEN firma IS NULL OR firma = '' THEN NULL
        WHEN regexp_replace(firma, '[^0-9]', '', 'g') = '' THEN NULL
        ELSE regexp_replace(firma, '[^0-9]', '', 'g')::INTEGER
    END,
    CASE WHEN trim(institucion) = '' THEN NULL ELSE upper(trim(institucion)) END
FROM stg_persona;
-- deje la normalización de teléfonos igual que cuando los validé en excel contra Persona_OK

INSERT INTO carga_log (mensaje)
SELECT format('[persona] staging=%s → insertadas=%s',
              (SELECT count(*) FROM stg_persona),
              (SELECT count(*) FROM persona));

-- vínculo inicial entre afiliados e instituciones usando el maestro de planes
INSERT INTO persona_plan (persona_id, institucion_nombre, grupo, es_titular, fecha_inicio, fecha_fin)
SELECT
    p.persona_id,
    ps.institucion_nombre,
    ps.grupo,
    (p.tipo_persona = 'titular'),
    NULL::date,
    NULL::date
FROM persona p
JOIN plan_salud ps ON ps.institucion_nombre = p.institucion_nombre
WHERE p.institucion_nombre IS NOT NULL;

INSERT INTO carga_log (mensaje)
SELECT format('[persona_plan] relaciones=%s', count(*))
FROM persona_plan;

-- Prestaciones FONASA.
CREATE TEMP TABLE stg_prestacion (
    codigo TEXT,
    codigo_adicional TEXT,
    descripcion TEXT,
    valor TEXT,
    grupo TEXT,
    tipo TEXT
) ON COMMIT DROP;

\copy stg_prestacion FROM 'Depurado/Arancel_Fonasa_OK.csv' WITH (FORMAT csv, HEADER true, DELIMITER ';');

INSERT INTO prestacion (codigo_fonasa, codigo_adicional, codigo_fonasa_full, descripcion, grupo, tipo, valor_fonasa)
SELECT
    trim(codigo),
    NULLIF(trim(codigo_adicional), ''),
    CASE
        WHEN COALESCE(NULLIF(trim(codigo_adicional), ''), '') = ''
            THEN trim(codigo)
        ELSE trim(codigo) || '-' || trim(codigo_adicional)
    END,
    trim(descripcion),
    trim(grupo),
    NULLIF(trim(tipo), ''),
    NULLIF(trim(valor), '')::INTEGER
FROM stg_prestacion;

INSERT INTO carga_log (mensaje)
SELECT format('[prestacion] staging=%s → insertadas=%s',
              (SELECT count(*) FROM stg_prestacion),
              (SELECT count(*) FROM prestacion));

-- Arancel propio dcc
CREATE TEMP TABLE stg_arancel_dc (
    codigo_interno TEXT,
    codigo_fonasa TEXT,
    descripcion TEXT,
    valor TEXT
) ON COMMIT DROP;

\copy stg_arancel_dc FROM 'Depurado/Arancel_DCColita_OK.csv' WITH (FORMAT csv, HEADER true, DELIMITER ';');

INSERT INTO arancel_dc (codigo_interno, codigo_fonasa, descripcion, valor_dc)
SELECT
    CAST(trim(codigo_interno) AS INTEGER),
    NULLIF(trim(codigo_fonasa), ''),
    trim(descripcion),
    NULLIF(trim(valor), '')::INTEGER
FROM stg_arancel_dc;

INSERT INTO carga_log (mensaje)
SELECT format('[arancel_dc] staging=%s → insertadas=%s',
              (SELECT count(*) FROM stg_arancel_dc),
              (SELECT count(*) FROM arancel_dc));

INSERT INTO carga_log (mensaje)
SELECT format('[prestacion_vs_arancel] coincidencias=%s discrepancias=%s',
              (SELECT count(*) FROM arancel_dc adc WHERE adc.codigo_fonasa IS NULL
                     OR EXISTS (SELECT 1 FROM prestacion p WHERE p.codigo_fonasa_full = adc.codigo_fonasa)),
              (SELECT count(*) FROM arancel_dc adc WHERE adc.codigo_fonasa IS NOT NULL
                     AND NOT EXISTS (SELECT 1 FROM prestacion p WHERE p.codigo_fonasa_full = adc.codigo_fonasa)));

-- Catálogo de farmacia
-- reutilizo la normalización del filtro para mantener los códigos alineados
CREATE TEMP TABLE stg_farmaco (
    codigo_generico INTEGER,
    nombre_generico TEXT,
    descripcion TEXT,
    tipo TEXT,
    codigo_onu TEXT,
    clasificacion_onu TEXT,
    clasificacion_interna TEXT,
    estado TEXT,
    canasta TEXT,
    precio TEXT
) ON COMMIT DROP;

\copy stg_farmaco FROM 'Depurado/Farmacia_OK.csv' WITH (FORMAT csv, HEADER true, DELIMITER ';');

INSERT INTO farmaco (
    farmaco_codigo,
    nombre_generico,
    descripcion,
    tipo,
    codigo_onu,
    clasificacion_onu,
    clasificacion_interna,
    estado,
    es_canasta_esencial,
    precio
)
SELECT
    codigo_generico,
    trim(nombre_generico),
    trim(descripcion),
    trim(tipo),
    NULLIF(trim(codigo_onu), '')::INTEGER,
    NULLIF(trim(clasificacion_onu), ''),
    trim(clasificacion_interna),
    lower(trim(estado)),
    CASE WHEN trim(canasta) = '1' THEN TRUE ELSE FALSE END,
    NULLIF(trim(precio), '')::INTEGER
FROM stg_farmaco;

INSERT INTO carga_log (mensaje)
SELECT format('[farmaco] staging=%s → insertadas=%s',
              (SELECT count(*) FROM stg_farmaco),
              (SELECT count(*) FROM farmaco));

CREATE TEMP TABLE farmaco_idx ON COMMIT DROP AS
SELECT DISTINCT ON (nombre_norm)
    farmaco_codigo,
    nombre_norm
FROM (
    SELECT
        farmaco_codigo,
        regexp_replace(
            translate(upper(trim(nombre_generico)), 'ÁÉÍÓÚÜÑ', 'AEIOUUN'),
            '[^A-Z0-9]+', '',
            'g'
        ) AS nombre_norm
    FROM farmaco
) f
WHERE nombre_norm <> ''
ORDER BY nombre_norm, farmaco_codigo;

INSERT INTO farmaco_idx (farmaco_codigo, nombre_norm)
SELECT
    farmaco_codigo,
    'VILDAGLIPTINAMETFORMINA501000MGCMCMREC'
FROM farmaco
WHERE regexp_replace(
        translate(upper(trim(nombre_generico)), 'ÁÉÍÓÚÜÑ', 'AEIOUUN'),
        '[^A-Z0-9]+', '',
        'g'
    ) = 'VILDAGLIPTINMETFORMIN501000MGCMREC'
  AND NOT EXISTS (
        SELECT 1 FROM farmaco_idx
        WHERE nombre_norm = 'VILDAGLIPTINAMETFORMINA501000MGCMCMREC'
    );
-- este parche con nombres complicados salió de comparar manualmente el csv en excel y copiar el código resultante

-- Atenciones médicas
CREATE TEMP TABLE stg_atencion (
    atencion_id INTEGER,
    fecha DATE,
    runpaciente TEXT,
    runmedico TEXT,
    diagnostico TEXT,
    efectuada TEXT
) ON COMMIT DROP;

\copy stg_atencion FROM 'Depurado/Atencion_OK.csv' WITH (FORMAT csv, HEADER true, DELIMITER ';');
-- confirmé en excel que las columnas estaban como atencion_id,fecha,runpaciente... antes de cargar

WITH atencion_normalizada AS (
    SELECT
        atencion_id,
        fecha,
        upper(trim(runpaciente)) AS paciente_run,
        upper(trim(runmedico)) AS profesional_run,
        NULLIF(trim(diagnostico), '') AS diagnostico,
        CASE WHEN upper(trim(efectuada)) = 'TRUE' THEN TRUE ELSE FALSE END AS efectuada
    FROM stg_atencion
)
INSERT INTO atencion (atencion_id, fecha, paciente_run, profesional_run, diagnostico, efectuada)
SELECT
    an.atencion_id,
    an.fecha,
    an.paciente_run,
    an.profesional_run,
    an.diagnostico,
    an.efectuada
FROM atencion_normalizada an
WHERE EXISTS (SELECT 1 FROM persona p WHERE p.run = an.paciente_run)
  AND EXISTS (SELECT 1 FROM persona p WHERE p.run = an.profesional_run);

INSERT INTO carga_log (mensaje)
SELECT format('[atencion] staging=%s → insertadas=%s (descartadas=%s)',
              (SELECT count(*) FROM stg_atencion),
              (SELECT count(*) FROM atencion),
              (SELECT count(*) FROM stg_atencion) - (SELECT count(*) FROM atencion));

-- Órdenes de procedimientos/exámenes.
-- solo cargo órdenes que refieren a prestaciones y atenciones válidas
CREATE TEMP TABLE stg_orden (
    atencion_id INTEGER,
    arancel_id INTEGER,
    descripcion TEXT
) ON COMMIT DROP;

\copy stg_orden FROM 'Depurado/Orden_OK.csv' WITH (FORMAT csv, HEADER true, DELIMITER ';');

INSERT INTO orden (atencion_id, codigo_arancel, descripcion)
SELECT
    so.atencion_id,
    so.arancel_id,
    trim(so.descripcion)
FROM stg_orden so
JOIN atencion a ON a.atencion_id = so.atencion_id
JOIN arancel_dc ad ON ad.codigo_interno = so.arancel_id;

INSERT INTO carga_log (mensaje)
SELECT format('[orden] staging=%s → insertadas=%s',
              (SELECT count(*) FROM stg_orden),
              (SELECT count(*) FROM orden));

-- Medicamentos prescritos.
-- intento machear con el catálogo de fármacos usando nombres normalizados
CREATE TEMP TABLE stg_medicamento (
    atencion_id INTEGER,
    medicamento TEXT,
    posologia TEXT,
    psicotropico TEXT
) ON COMMIT DROP;

\copy stg_medicamento FROM 'Depurado/Medicamento_OK.csv' WITH (FORMAT csv, HEADER true, DELIMITER ';');

CREATE TEMP TABLE medicamento_preparado ON COMMIT DROP AS
SELECT
    sm.atencion_id,
    trim(sm.medicamento) AS medicamento,
    trim(sm.posologia) AS posologia,
    CASE WHEN upper(trim(sm.psicotropico)) = 'TRUE' THEN TRUE ELSE FALSE END AS es_psicotropico,
    regexp_replace(
        translate(upper(trim(sm.medicamento)), 'ÁÉÍÓÚÜÑ', 'AEIOUUN'),
        '[^A-Z0-9]+', '',
        'g'
    ) AS medicamento_norm,
    EXISTS (SELECT 1 FROM atencion a WHERE a.atencion_id = sm.atencion_id) AS tiene_atencion
FROM stg_medicamento sm;

CREATE TEMP TABLE medicamento_con_farmaco ON COMMIT DROP AS
SELECT
    mp.*,
    fi.farmaco_codigo
FROM medicamento_preparado mp
LEFT JOIN farmaco_idx fi ON fi.nombre_norm = mp.medicamento_norm;

INSERT INTO medicamento_prescrito (
    atencion_id,
   medicamento_nombre,
    farmaco_codigo,
    posologia,
    es_psicotropico
)
SELECT
    atencion_id,
    medicamento,
    farmaco_codigo,
    posologia,
    es_psicotropico
FROM medicamento_con_farmaco
WHERE tiene_atencion;

INSERT INTO carga_log (mensaje)
SELECT format('[medicamento_prescrito] staging=%s → insertadas=%s (sin_atencion=%s, sin_catalogo=%s)',
              (SELECT count(*) FROM stg_medicamento),
              (SELECT count(*) FROM medicamento_prescrito),
              (SELECT count(*) FROM medicamento_preparado WHERE NOT tiene_atencion),
              (SELECT count(*) FROM medicamento_con_farmaco WHERE tiene_atencion AND farmaco_codigo IS NULL));

INSERT INTO carga_log (mensaje)
SELECT format('[tabla] %s', table_name)
FROM information_schema.tables
WHERE table_schema = 'dccolita'
  AND table_name IN (
        'institucion_previsional',
        'firma',
        'plan_salud',
        'persona',
        'persona_plan',
        'prestacion',
        'arancel_dc',
        'farmaco',
        'atencion',
        'orden',
        'medicamento_prescrito')
ORDER BY table_name;

INSERT INTO carga_log (mensaje)
SELECT format('[estructura] %s.%s %s%s %s',
              c.table_name,
              c.column_name,
              c.data_type,
              CASE
                  WHEN c.character_maximum_length IS NOT NULL THEN format('(%s)', c.character_maximum_length)
                  WHEN c.numeric_precision IS NOT NULL THEN format('(%s,%s)', c.numeric_precision, c.numeric_scale)
                  ELSE ''
              END,
              CASE WHEN c.is_nullable = 'YES' THEN 'NULL' ELSE 'NOT NULL' END)
FROM information_schema.columns c
WHERE c.table_schema = 'dccolita'
  AND c.table_name IN (
        'institucion_previsional',
        'firma',
        'plan_salud',
        'persona',
        'persona_plan',
        'prestacion',
        'arancel_dc',
        'farmaco',
        'atencion',
        'orden',
        'medicamento_prescrito')
ORDER BY c.table_name, c.ordinal_position;

INSERT INTO carga_log (mensaje)
VALUES ('[fin] Exportando bitácora a RegistrosSQL/cargaLOG.txt');
-- cierro dejando la bitácora en el mismo formato que usamos para la entrega

\copy (SELECT mensaje FROM carga_log ORDER BY orden) TO 'RegistrosSQL/cargaLOG.txt';

COMMIT;
